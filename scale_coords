# 如果运行时报出了“未能从general.py中导入scale_coords”之类的错误，可以尝试将以下函数添加到general.py的末尾或者直接加到主脚本中
def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None):
    """
    将检测框的坐标从模型输入图像尺寸（img1_shape）映射回原始图像尺寸（img0_shape）。

    Args:
        img1_shape (tuple): 模型输入图像的尺寸 (height, width)
        coords (torch.Tensor 或 numpy.ndarray): 检测框的坐标 (x1, y1, x2, y2)
        img0_shape (tuple): 原始图像的尺寸 (height, width)
        ratio_pad (tuple, optional): 缩放比例和填充值 (scaling_ratio, (pad_width, pad_height))

    Returns:
        numpy.ndarray 或 torch.Tensor: 映射到原始图像的检测框坐标。
    """
    # 如果没有提供 ratio_pad，计算缩放比例和填充值
    if ratio_pad is None:
        gain = max(img1_shape) / max(img0_shape)  # gain: 缩放比例
        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # 宽度和高度的填充
    else:
        gain, pad = ratio_pad

    # 如果 coords 是 PyTorch 张量，将其移动到 CPU 并转换为 NumPy 数组
    if isinstance(coords, torch.Tensor):
        coords = coords.cpu().numpy()

    # 处理坐标，以映射回原始图像尺寸
    coords[:, [0, 2]] -= pad[0]  # 移除 x 方向的填充
    coords[:, [1, 3]] -= pad[1]  # 移除 y 方向的填充
    coords[:, :4] /= gain  # 缩放

    # 裁剪坐标到图像边界
    coords[:, 0::2] = np.clip(coords[:, 0::2], 0, img0_shape[1])  # 裁剪 x 坐标
    coords[:, 1::2] = np.clip(coords[:, 1::2], 0, img0_shape[0])  # 裁剪 y 坐标

    return coords
